// Variables globales
const dropZone = document.getElementById('dropZone');
const results = document.getElementById('results');
let currentFilePath = null;

// Support hybride pour l'ancien et le nouveau système
let electronAPI;

// Fonction pour initialiser l'API (ancien ou nouveau système)
function initializeElectronAPI() {
    if (window.electronAPI) {
        // Nouveau système avec contextBridge
        console.log('Utilisation du nouveau système electronAPI');
        electronAPI = window.electronAPI;
        return true;
    } else if (window.require) {
        // Ancien système avec nodeIntegration
        console.log('Utilisation de l\'ancien système avec ipcRenderer');
        const { ipcRenderer } = window.require('electron');
        electronAPI = {
            readFile: (filePath) => ipcRenderer.invoke('read-file', filePath),
            openFileDialog: () => ipcRenderer.send('open-file-dialog'),
            quitApp: () => ipcRenderer.send('quit-app'),
            onFileToOpen: (callback) => ipcRenderer.on('file-to-open', (event, filePath) => callback(filePath)),
            onFileSelected: (callback) => ipcRenderer.on('file-selected', (event, filePath) => callback(filePath)),
            exportToPDF: (htmlContent, patientName) => ipcRenderer.invoke('export-pdf', htmlContent, patientName)
        };
        return true;
    }
    return false;
}

// Fonctions utilitaires pour l'affichage des messages (définies en premier)
function showError(message, filePath = null) {
    let html = `<div style="color: red; padding: 20px; background: #fee; border-radius: 8px; border-left: 4px solid #d32f2f;">
        <strong>Erreur</strong><br>
        ${escapeHtml(message)}`;
    
    if (filePath) {
        html += `<br><small style="color: #666;">Fichier: ${escapeHtml(filePath)}</small>`;
    }
    
    html += '</div>';
    results.innerHTML = html;
}

function showLoading(message) {
    results.innerHTML = `<div style="color: blue; padding: 20px; background: #e3f2fd; border-radius: 8px; border-left: 4px solid #1976d2;">
        <strong>Chargement...</strong><br>
        ${escapeHtml(message)}
    </div>`;
}

function showInfo(message) {
    results.innerHTML = `<div style="color: #666; padding: 20px; background: #f5f5f5; border-radius: 8px; border-left: 4px solid #666;">
        <strong>Information</strong><br>
        ${escapeHtml(message)}
    </div>`;
}

// Fonction pour sécuriser l'affichage des chemins de fichier
function sanitizeFilePath(filePath) {
    if (!filePath) return '';
    // Afficher seulement le nom du fichier, pas le chemin complet
    return filePath.split(/[/\\]/).pop() || filePath;
}

// Fonction pour échapper les caractères HTML
function escapeHtml(unsafe) {
    if (typeof unsafe !== 'string') return '';
    return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}

// Vérifier si l'API Electron est disponible
function checkElectronAPI() {
    if (!electronAPI) {
        console.error('ElectronAPI non disponible');
        showError('Erreur de communication avec l\'application. Veuillez redémarrer.');
        return false;
    }
    return true;
}

// Initialiser les événements IPC une fois que l'API est disponible
function initializeIPC() {
    if (!checkElectronAPI()) return;
    
    // Écouter les événements d'ouverture de fichier
    electronAPI.onFileToOpen((filePath) => {
        console.log('Fichier reçu:', filePath);
        handleFile(filePath);
    });

    electronAPI.onFileSelected((filePath) => {
        console.log('Fichier sélectionné:', filePath);
        handleFile(filePath);
    });
}

// Fonction pour traiter un fichier
async function handleFile(filePath) {
    console.log('handleFile appelé avec:', filePath);
    
    // Validation de base du chemin de fichier
    if (!filePath || typeof filePath !== 'string' || filePath.trim() === '') {
        console.error('Aucun chemin de fichier fourni ou invalide');
        showError('Aucun fichier spécifié ou chemin invalide');
        return;
    }
    
    // Validation de l'extension du fichier
    const allowedExtensions = ['.hpr', '.hpm', '.hprim', '.txt'];
    const fileExtension = filePath.toLowerCase().substring(filePath.lastIndexOf('.'));
    if (!allowedExtensions.includes(fileExtension)) {
        console.error('Type de fichier non supporté:', fileExtension);
        showError(`Type de fichier non supporté: ${fileExtension}. Extensions acceptées: ${allowedExtensions.join(', ')}`);
        return;
    }
    
    try {
        console.log('Tentative de lecture du fichier:', filePath);
        currentFilePath = filePath;
        
        // Afficher le message de chargement
        showLoading(`Chargement du fichier: ${sanitizeFilePath(filePath)}`);
        
        // Vérifier que l'API est disponible
        if (!checkElectronAPI()) return;
        
        // Lire le fichier avec Electron
        const content = await electronAPI.readFile(filePath);
        
        // Validation du contenu
        if (!content) {
            throw new Error('Le fichier est vide ou illisible');
        }
        
        if (content.length > 10 * 1024 * 1024) { // 10MB limit
            throw new Error('Le fichier est trop volumineux (limite: 10MB)');
        }
        
        console.log('Contenu lu, longueur:', content.length);
        
        console.log('Début du parsing et affichage...');
        const parsedResults = parseAndDisplay(content);
        
        if (!parsedResults || parsedResults.length === 0) {
            showInfo('Aucun résultat trouvé dans ce fichier. Vérifiez que le fichier contient des données HPRIM valides.');
        } else {
            console.log('Fichier traité avec succès');
        }
        
    } catch (error) {
        console.error('Erreur détaillée lors de la lecture du fichier:', error);
        
        let errorMsg = 'Erreur lors de la lecture du fichier';
        
        // Messages d'erreur spécifiques
        if (error.message.includes('ENOENT')) {
            errorMsg = 'Fichier non trouvé';
        } else if (error.message.includes('EACCES')) {
            errorMsg = 'Accès refusé au fichier';
        } else if (error.message.includes('Path traversal')) {
            errorMsg = 'Chemin de fichier non autorisé';
        } else if (error.message.includes('File type not allowed')) {
            errorMsg = 'Type de fichier non autorisé';
        } else if (error.message) {
            errorMsg += ': ' + error.message;
        }
        
        showError(errorMsg, sanitizeFilePath(filePath));
    }
}


// Fonction pour attendre que l'API soit disponible
function waitForElectronAPI(callback, maxAttempts = 10) {
    let attempts = 0;
    
    function checkAPI() {
        attempts++;
        console.log(`Tentative ${attempts}: Initialisation de l'API...`);
        
        if (initializeElectronAPI()) {
            console.log('API initialisée avec succès');
            console.log('API methods:', Object.keys(electronAPI));
            callback();
        } else if (attempts < maxAttempts) {
            setTimeout(checkAPI, 200);
        } else {
            console.error('Impossible de charger electronAPI après', maxAttempts, 'tentatives');
            showError('Erreur de chargement de l\'application. Vérifiez que vous utilisez Electron.');
        }
    }
    
    checkAPI();
}

// Initialiser l'application après le chargement du DOM
document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM chargé');
    console.log('window.electronAPI disponible:', !!window.electronAPI);
    console.log('window.require disponible:', !!window.require);
    
    // Afficher le message d'accueil
    results.innerHTML = '<p style="color: #666;">Utilisez Cmd+O pour ouvrir un fichier ou glissez-déposez un fichier .hpr dans cette fenêtre.</p>';
    
    // Attendre que l'API soit disponible
    waitForElectronAPI(() => {
        initializeIPC();
        // Initialiser l'état du bouton PDF
        updatePDFButton();
    });
});

// Drag & Drop
dropZone.addEventListener('dragover', (e) => {
    console.log('Dragover event');
    e.preventDefault();
    dropZone.classList.add('dragover');
});

dropZone.addEventListener('dragleave', (e) => {
    console.log('Dragleave event');
    e.preventDefault();
    dropZone.classList.remove('dragover');
});

dropZone.addEventListener('drop', async (e) => {
    console.log('Drop event');
    e.preventDefault();
    dropZone.classList.remove('dragover');
    
    const files = e.dataTransfer.files;
    console.log('Files dropped:', files.length);
    if (files.length > 0) {
        console.log('File path:', files[0].path);
        await handleFile(files[0].path);
    }
});

// Clic sur la zone de drop pour ouvrir un fichier
dropZone.addEventListener('click', () => {
    console.log('Drop zone clicked');
    if (!checkElectronAPI()) return;
    console.log('Sending open file dialog request');
    // Envoyer un message au processus principal pour ouvrir la boîte de dialogue
    electronAPI.openFileDialog();
});

// Support clavier pour la zone de drop
dropZone.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        if (!checkElectronAPI()) return;
        electronAPI.openFileDialog();
    }
});

// ============================================================================
// FONCTIONS POUR LES BOUTONS DE L'INTERFACE
// ============================================================================

// Fonction pour ouvrir un fichier (bouton "Ouvrir")
function openFile() {
    console.log('openFile function called');
    if (!checkElectronAPI()) return;
    console.log('Sending open file dialog request from button');
    electronAPI.openFileDialog();
}

// Fonction pour quitter l'application (bouton "Quitter")
function quitApp() {
    console.log('quitApp function called');
    if (!checkElectronAPI()) return;
    console.log('Sending quit app request');
    electronAPI.quitApp();
}

// Fonction pour exporter en PDF
async function exportToPDF() {
    console.log('Export PDF demandé');
    
    if (!checkElectronAPI()) return;
    
    // Vérifier qu'il y a des résultats à exporter
    const resultsContent = results.innerHTML;
    if (!resultsContent || resultsContent.includes('Les résultats apparaîtront ici') || resultsContent.includes('Utilisez Cmd+O')) {
        showError('Aucun résultat à exporter. Chargez d\'abord un fichier HPRIM.');
        return;
    }

    try {
        // Extraire le nom du patient depuis l'en-tête si disponible
        const patientHeader = document.querySelector('div[style*="background: #e3f2fd"]');
        let patientName = 'Patient';
        
        if (patientHeader) {
            const nameMatch = patientHeader.textContent.match(/([A-Z\s-]+)\s+\d+\s+ans/);
            if (nameMatch) {
                patientName = nameMatch[1].trim().replace(/\s+/g, '_');
            }
        }

        showLoading('Génération du PDF en cours...');

        // Appeler l'export PDF
        const result = await electronAPI.exportToPDF(resultsContent, patientName);

        if (result.success) {
            showInfo(`PDF exporté avec succès vers :<br><strong>${sanitizeFilePath(result.path)}</strong>`);
        } else if (result.cancelled) {
            results.innerHTML = '<p style="color: #666;">Export PDF annulé.</p>';
        } else {
            throw new Error(result.error || 'Erreur inconnue lors de l\'export PDF');
        }

    } catch (error) {
        console.error('Erreur export PDF:', error);
        showError('Erreur lors de l\'export PDF: ' + error.message);
    }
}

// Activer/désactiver le bouton PDF selon le contenu
function updatePDFButton() {
    const pdfBtn = document.getElementById('pdfBtn');
    if (pdfBtn) {
        const hasResults = results.innerHTML && 
                          !results.innerHTML.includes('Les résultats apparaîtront ici') &&
                          !results.innerHTML.includes('Utilisez Cmd+O') &&
                          !results.innerHTML.includes('Sélectionnez un fichier') &&
                          !results.innerHTML.includes('Prêt à analyser');
        
        pdfBtn.disabled = !hasResults;
        pdfBtn.style.opacity = hasResults ? '1' : '0.5';
        pdfBtn.title = hasResults ? 'Exporter les résultats en PDF' : 'Aucun résultat à exporter';
    }
}

// ============================================================================
// COPIE EXACTE DU CODE DE PARSING DEPUIS LE FICHIER ORIGINAL
// ============================================================================

function parseAndDisplay(content) {
    console.log('parseAndDisplay called with content length:', content.length);
    
    try {
        // Cacher la zone de drag & drop une fois qu'un fichier est ouvert
        dropZone.style.display = 'none';
        
        // Extraire les informations patient avec gestion d'erreur
        let patientInfo = {};
        try {
            patientInfo = extractPatientInfo(content);
            console.log('Patient info:', patientInfo);
        } catch (error) {
            console.warn('Erreur lors de l\'extraction des informations patient:', error);
            patientInfo = {};
        }
        
        // Parser le contenu HPRIM avec gestion d'erreur
        let parsed = [];
        try {
            parsed = parseHPRIM(content);
            console.log('Parsed results:', parsed);
        } catch (error) {
            console.error('Erreur lors du parsing HPRIM:', error);
            showError('Erreur lors de l\'analyse du fichier HPRIM. Le format pourrait être invalide.');
            return [];
        }
        
        if (!parsed || parsed.length === 0) {
            showInfo('Aucun résultat médical trouvé dans ce fichier.');
            return [];
        }
        
        let html = '';
        
        // Ajouter l'en-tête patient si disponible
        if (patientInfo.patientName || patientInfo.samplingDate) {
            try {
                html += generatePatientHeader(patientInfo);
            } catch (error) {
                console.warn('Erreur lors de la génération de l\'en-tête patient:', error);
            }
        }
        
        // Générer l'affichage des résultats
        for (const result of parsed) {
            try {
                // Validation des données de résultat
                if (!result.name) {
                    console.warn('Résultat sans nom ignoré:', result);
                    continue;
                }
                
                // Couleur de bordure seulement si il y a des normes
                let abnormalClass = '';
                if (result.hasNorms) {
                    abnormalClass = result.isAbnormal ? 'style="border-left-color: #ff5722;"' : 'style="border-left-color: #4caf50;"';
                }
                
                // Construire l'affichage avec colonnes alignées
                const formattedValue1 = formatValue(result.value1, result.operator1 || null, result.isHighlighted1 || false);
                const formattedNormes1 = formatNorms(result.min1, result.max1, result);
                
                let valuesColumn = `<div class="value-line">
                    <span class="result-number">${escapeHtml(formattedValue1)}</span>
                    <span class="result-unit">${escapeHtml(result.unit1 || '')}</span>
                </div>`;
                
                let normsColumn = `<div class="result-norms">${escapeHtml(formattedNormes1)}</div>`;
                
                if (result.hasMultipleUnits) {
                    const formattedValue2 = formatValue(result.value2, result.operator2 || null, result.isHighlighted2 || false);
                    const formattedNormes2 = formatNorms(result.min2, result.max2, result);
                    
                    valuesColumn += `<div class="value-line">
                        <span class="result-number">${escapeHtml(formattedValue2)}</span>
                        <span class="result-unit">${escapeHtml(result.unit2 || '')}</span>
                    </div>`;
                    
                    normsColumn += `<div class="result-norms">${escapeHtml(formattedNormes2)}</div>`;
                }
                
                // Commentaires associés
                let commentsHtml = '';
                if (result.comments && Array.isArray(result.comments) && result.comments.length > 0) {
                    // Regrouper tous les commentaires en un seul bloc pour éviter les interlignes
                    const allComments = result.comments
                        .filter(comment => comment && typeof comment === 'string' && comment.trim())
                        .map(comment => escapeHtml(comment.trim()))
                        .join(' ');
                    
                    if (allComments) {
                        commentsHtml += `<div style="grid-column: 1 / -1; margin-top: 8px; padding: 4px 8px; background: #f8f9fa; border-radius: 3px; font-size: 0.7em; color: #666; line-height: 1.1; font-family: Arial, Helvetica, sans-serif; font-style: italic; font-weight: 300;">
                            ${allComments}
                        </div>`;
                    }
                }
                
                html += `
                    <div class="result-item" ${abnormalClass}>
                        <div class="result-name">${escapeHtml(result.name)}</div>
                        <div class="result-value-container">${valuesColumn}</div>
                        <div>${normsColumn}</div>
                        ${commentsHtml}
                    </div>
                `;
            } catch (error) {
                console.error('Erreur lors du formatage d\'un résultat:', error, result);
                // Continuer avec les autres résultats
            }
        }
        
        results.innerHTML = html || '<p>Aucun résultat trouvé</p>';
        
        // Activer le bouton PDF maintenant qu'il y a des résultats
        updatePDFButton();
        
        return parsed;
        
    } catch (error) {
        console.error('Erreur critique dans parseAndDisplay:', error);
        showError('Erreur critique lors de l\'affichage des résultats');
        return [];
    }
}

// Fonction pour détecter le format HPRIM
function detectHPRIMFormat(content) {
    if (content.includes('****LAB****') && content.includes('****FIN****')) {
        return 'structured_tags';
    } else if (content.includes('RES|') && content.split('RES|').length > 2) {
        return 'structured_pipes';
    } else if (content.includes('VR:') || content.includes('g/dL') || content.includes('/mm3')) {
        return 'text_readable';
    } else {
        return 'unknown';
    }
}

// Fonction pour décoder les entités HTML
function decodeHTMLEntities(text) {
    if (!text || typeof text !== 'string') return text;
    
    return text
        .replace(/&eacute;/g, 'é')
        .replace(/&egrave;/g, 'è')
        .replace(/&agrave;/g, 'à')
        .replace(/&acirc;/g, 'â')
        .replace(/&ocirc;/g, 'ô')
        .replace(/&ucirc;/g, 'û')
        .replace(/&icirc;/g, 'î')
        .replace(/&ccedil;/g, 'ç')
        .replace(/&deg;/g, '°')
        .replace(/&#039;/g, "'")
        .replace(/<br\s*\/?>/g, '\n')
        .replace(/<[^>]+>/g, ''); // Supprimer autres balises HTML
}

// Fonction pour normaliser les valeurs numériques (virgule vers point)
function normalizeNumericValue(value) {
    if (!value || typeof value !== 'string') return value;
    
    // Remplacer virgule par point pour les décimales
    return value.replace(',', '.');
}

function parseHPRIM(content) {
    console.log('Parsing HPRIM avec détection automatique de format...');
    
    // Détecter le format du fichier
    const format = detectHPRIMFormat(content);
    console.log('Format détecté:', format);
    
    // Décoder les entités HTML dans tout le contenu
    const decodedContent = decodeHTMLEntities(content);
    
    // Router vers le bon parser selon le format
    switch(format) {
        case 'structured_tags':
            return parseStructuredTagsHPRIM(decodedContent);
        case 'structured_pipes':
            return parseStructuredPipesHPRIM(decodedContent);
        case 'text_readable':
            return parseTextReadableHPRIM(decodedContent);
        default:
            console.warn('Format HPRIM non reconnu, tentative de parsing générique...');
            return parseStructuredPipesHPRIM(decodedContent); // Fallback vers l'ancien parser
    }
}

// Parser pour format avec tags ****LAB**** (nouveau)
function parseStructuredTagsHPRIM(content) {
    console.log('Parsing format structuré avec tags...');
    const rawResults = [];
    const lines = content.split('\n');
    
    let inLabSection = false;
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        if (line.includes('****LAB****')) {
            inLabSection = true;
            continue;
        }
        
        if (line.includes('****FIN****')) {
            inLabSection = false;
            continue;
        }
        
        if (inLabSection && line.startsWith('RES|')) {
            // Traiter comme le format pipes standard
            const result = parseRESLine(line);
            if (result) rawResults.push(result);
        }
    }
    
    return processRawResults(rawResults);
}

// Parser pour format structuré avec pipes RES| (amélioré)
function parseStructuredPipesHPRIM(content) {
    console.log('Parsing format structuré avec pipes...');
    const rawResults = [];
    const lines = content.split('\n');
    
    // Stratégie différente : d'abord identifier le DFG puis collecter tous ses commentaires
    let dfgIndex = -1;
    let dfgComments = [];
    
    // Trouver l'index du DFG
    for (let i = 0; i < lines.length; i++) {
        if (lines[i].startsWith('RES|') && (lines[i].toLowerCase().includes('dfg') || lines[i].toLowerCase().includes('ckd-epi'))) {
            dfgIndex = i;
            break;
        }
    }
    
    // Si on a trouvé le DFG, collecter tous les TEX| avant et après
    if (dfgIndex !== -1) {
        // Collecter les TEX| avant le DFG (en remontant)
        for (let i = dfgIndex - 1; i >= 0 && lines[i].startsWith('TEX|'); i--) {
            const textContent = lines[i].substring(4).trim();
            if (textContent && textContent.length > 3 && !textContent.includes('----')) {
                const cleanText = textContent
                    .replace(/&eacute;/g, 'é')
                    .replace(/&deg;/g, '°')
                    .replace(/&#039;/g, "'")
                    .replace(/<br \/>/g, ' ')
                    .replace(/\n/g, ' ')
                    .replace(/\r/g, ' ');
                dfgComments.unshift(cleanText); // unshift pour garder l'ordre
            }
        }
        
        // Collecter les TEX| après le DFG
        for (let i = dfgIndex + 1; i < lines.length && lines[i].startsWith('TEX|'); i++) {
            const textContent = lines[i].substring(4).trim();
            if (textContent && textContent.length > 3 && !textContent.includes('----')) {
                const cleanText = textContent
                    .replace(/&eacute;/g, 'é')
                    .replace(/&deg;/g, '°')
                    .replace(/&#039;/g, "'")
                    .replace(/<br \/>/g, ' ')
                    .replace(/\n/g, ' ')
                    .replace(/\r/g, ' ');
                dfgComments.push(cleanText);
            }
        }
    }
    
    // Debug: vérifier les premières lignes qui contiennent RES
    console.log('Looking for RES lines...');
    const resLines = lines.filter(line => line.includes('RES|'));
    console.log(`Found ${resLines.length} lines containing RES|`);
    if (resLines.length > 0) {
        console.log('First RES line:', JSON.stringify(resLines[0]));
        console.log('Starts with RES|?', resLines[0].startsWith('RES|'));
    }
    
    // Vérifier s'il y a des lignes RES| dans le fichier
    const hasResLines = lines.some(line => line.startsWith('RES|'));
    
    if (!hasResLines) {
        // Format texte libre - parser différemment
        return parseTextReadableHPRIM(content);
    }
    
    // Maintenant parser normalement (format structuré)
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        
        if (line.startsWith('RES|')) {
            const parts = line.split('|');
            console.log('Ligne RES trouvée, parts.length:', parts.length, 'Line:', line);
            if (parts.length >= 8) {
                const name = parts[1] ? parts[1].trim() : '';
                const code = parts[2] ? parts[2].trim() : '';
                const type = parts[3] ? parts[3].trim() : '';
                const valueStr = parts[4] ? parts[4].trim() : '';
                console.log('RES ligne trouvée:', line);
                console.log('Name:', name, 'ValueStr:', valueStr);
                const unit = parts[5] ? parts[5].trim() : '';
                const normStr = parts[6] ? parts[6].trim() : '';
                let maxStr = parts[7] ? parts[7].trim() : '';
                
                // Parser les normes au format "3,2-6,5" ou séparées
                let minStr = '';
                if (normStr && normStr.includes('-')) {
                    const normParts = normStr.split('-');
                    minStr = normParts[0].trim();
                    if (normParts.length > 1 && !maxStr) {
                        maxStr = normParts[1].trim();
                    }
                } else {
                    minStr = normStr;
                }
                const status = parts[8] ? parts[8].trim() : '';
                
                const value2Str = parts[10] ? parts[10].trim() : '';
                const unit2 = parts[11] ? parts[11].trim() : '';
                const norm2Str = parts[12] ? parts[12].trim() : '';
                let max2Str = parts[13] ? parts[13].trim() : '';
                
                // Parser les normes 2 au format "3,2-6,5" ou séparées
                let min2Str = '';
                if (norm2Str && norm2Str.includes('-')) {
                    const norm2Parts = norm2Str.split('-');
                    min2Str = norm2Parts[0].trim();
                    if (norm2Parts.length > 1 && !max2Str) {
                        max2Str = norm2Parts[1].trim();
                    }
                } else {
                    min2Str = norm2Str;
                }
                
                if ((type === 'N' || type === 'A') && valueStr && name) {
                    console.log('Result added:', name, 'Type:', type, 'Value:', valueStr);
                    const cleanName = name.replace(/\s+/g, ' ').trim();
                    
                    // Vérifier si c'est une ligne "soit" qui doit être fusionnée avec la précédente
                    if (cleanName.toLowerCase() === 'soit' && rawResults.length > 0) {
                        // Fusionner avec le dernier résultat
                        const lastResult = rawResults[rawResults.length - 1];
                        const parsedValue = parseSpecialValue(valueStr);
                        
                        // Ajouter comme deuxième valeur/unité
                        lastResult.value2 = parsedValue.value;
                        lastResult.unit2 = unit;
                        lastResult.min2 = parseNorm(minStr);
                        lastResult.max2 = parseNorm(max2Str);
                        lastResult.hasMultipleUnits = true;
                        continue;
                    }
                    
                    const parsedValue = parseSpecialValue(valueStr);
                    
                    const result = {
                        name: cleanName,
                        value1: parsedValue.value,
                        unit1: unit,
                        min1: parseNorm(minStr),
                        max1: parseNorm(max2Str),
                        status: status,
                        type: type,
                        isHighlighted1: parsedValue.highlighted || status === 'H' || status === 'L',
                        hasNorms: !!(minStr || max2Str),
                        comments: []
                    };
                    
                    // Ajouter la deuxième valeur si elle existe
                    if (value2Str) {
                        const parsedValue2 = parseSpecialValue(value2Str);
                        result.value2 = parsedValue2.value;
                        result.unit2 = unit2;
                        result.min2 = parseNorm(min2Str);
                        result.max2 = parseNorm(max2Str);
                        result.isHighlighted2 = parsedValue2.highlighted;
                        result.hasMultipleUnits = true;
                    }
                    
                    // Ajouter commentaires spéciaux pour le DFG
                    if (cleanName.toLowerCase().includes('dfg') || cleanName.toLowerCase().includes('ckd-epi')) {
                        result.comments = dfgComments;
                    }
                    
                    rawResults.push(result);
                }
            }
        }
        
        return processRawResults(rawResults);
    }
    
    // Parser pour format texte lisible (nouveau)
    function parseTextReadableHPRIM(content) {
        console.log('Parsing format texte lisible...');
        const rawResults = [];
        const lines = content.split('\n');
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            
            // Chercher les lignes avec des valeurs de référence
            if (line.includes('VR:') || (line.includes('g/dL') && (line.includes(',') || line.includes('.')))) {
                const result = parseTextResultLine(line);
                if (result) rawResults.push(result);
            }
        }
        
        return processRawResults(rawResults);
    }
    
    // Fonction pour parser une ligne de résultat en format texte
    function parseTextResultLine(line) {
        // Pattern pour: NOM_TEST    VALEUR   UNITÉ   VR: MIN - MAX
        const patterns = [
            /^\s*([^\d]+?)\s+([*]?\d+[.,]?\d*[*]?)\s+([^\s]+)\s+VR:\s*([\d.,]+)\s*-\s*([\d.,]+)/,
            /^\s*([^\d]+?)\s+([*]?\d+[.,]?\d*[*]?)\s+([^\s]+)\s+VR:\s*<\s*([\d.,]+)/,
            /^\s*([^\d]+?)\s+([*]?\d+[.,]?\d*[*]?)\s+([^\s]+)\s+VR:\s*>\s*([\d.,]+)/
        ];
        
        for (const pattern of patterns) {
            const match = line.match(pattern);
            if (match) {
                const name = match[1].trim();
                const valueStr = match[2].trim();
                const unit = match[3].trim();
                
                const parsedValue = parseSpecialValue(valueStr);
                
                let min1 = null, max1 = null;
                if (match[4]) {
                    if (pattern.source.includes('<')) {
                        max1 = parseNorm(match[4]);
                    } else if (pattern.source.includes('>')) {
                        min1 = parseNorm(match[4]);
                    } else {
                        min1 = parseNorm(match[4]);
                        max1 = match[5] ? parseNorm(match[5]) : null;
                    }
                }
                
                return {
                    name: name,
                    value1: parsedValue.value,
                    unit1: unit,
                    min1: min1,
                    max1: max1,
                    isHighlighted1: parsedValue.highlighted,
                    hasNorms: !!(min1 || max1),
                    comments: []
                };
            }
        }
        
        return null;
    }
    
    // Fonction pour parser une ligne RES|
    function parseRESLine(line) {
        const parts = line.split('|');
        if (parts.length < 8) return null;
        
        const name = parts[1] ? parts[1].trim() : '';
        const valueStr = parts[4] ? parts[4].trim() : '';
        const unit = parts[5] ? parts[5].trim() : '';
        const normStr = parts[6] ? parts[6].trim() : '';
        const maxStr = parts[7] ? parts[7].trim() : '';
        const status = parts[8] ? parts[8].trim() : '';
        const type = parts[3] ? parts[3].trim() : '';
        
        if ((type === 'N' || type === 'A') && valueStr && name) {
            const parsedValue = parseSpecialValue(valueStr);
            
            return {
                name: name.trim(),
                value1: parsedValue.value,
                unit1: unit,
                min1: parseNorm(normStr),
                max1: parseNorm(maxStr),
                status: status,
                type: type,
                isHighlighted1: parsedValue.highlighted || status === 'H' || status === 'L',
                hasNorms: !!(normStr || maxStr),
                comments: []
            };
        }
        
        return null;
    }
    
    // Fonction pour traiter les résultats bruts
    function processRawResults(rawResults) {
        console.log(`Processing ${rawResults.length} raw results...`);
        
        // Filtrer et nettoyer les résultats
        const processedResults = rawResults.filter(result => {
            return result && result.name && result.value1 !== null && result.value1 !== undefined;
        }).map(result => {
            // Calculer si le résultat est anormal
            result.isAbnormal = false;
            if (result.hasNorms && result.value1 !== null) {
                const numValue = parseFloat(result.value1);
                if (!isNaN(numValue)) {
                    if (result.min1 !== null && numValue < result.min1) {
                        result.isAbnormal = true;
                    }
                    if (result.max1 !== null && numValue > result.max1) {
                        result.isAbnormal = true;
                    }
                }
            }
            
            return result;
        });
        
        console.log(`Processed ${processedResults.length} valid results`);
        return processedResults;
    }
    
    // Fonction pour parser les valeurs spéciales (avec * ou < >)
    function parseSpecialValue(valueStr) {
        if (!valueStr || typeof valueStr !== 'string') {
            return { value: null, highlighted: false };
        }
        
        let cleanValue = valueStr.trim();
        let highlighted = false;
        
        // Détecter les valeurs mises en évidence avec *
        if (cleanValue.startsWith('*') && cleanValue.endsWith('*')) {
            highlighted = true;
            cleanValue = cleanValue.slice(1, -1);
        }
        
        // Détecter les opérateurs < ou >
        if (cleanValue.startsWith('<') || cleanValue.startsWith('>')) {
            cleanValue = cleanValue.substring(1);
        }
        
        // Normaliser la valeur numérique (virgule vers point)
        cleanValue = normalizeNumericValue(cleanValue);
        
        // Tenter de convertir en nombre
        const numValue = parseFloat(cleanValue);
        if (!isNaN(numValue)) {
            return { value: numValue, highlighted: highlighted };
        }
        
        // Retourner comme chaîne si ce n'est pas un nombre
        return { value: cleanValue, highlighted: highlighted };
    }
    
    // Fonction pour parser les normes
    function parseNorm(normStr) {
        if (!normStr || typeof normStr !== 'string') return null;
        
        const cleaned = normalizeNumericValue(normStr.trim());
        const num = parseFloat(cleaned);
        return isNaN(num) ? null : num;
    }

// Fin des fonctions d'analyse HPRIM

// ============================================================================
// FONCTIONS POUR L'EXTRACTION DES INFORMATIONS PATIENT
// ============================================================================

function extractPatientInfo(content) {
    const lines = content.split('\n');
    const info = {};
    
    // Extraction du nom patient (lignes 2-3)
    info.patientName = extractPatientName(lines);
    
    // Extraction des dates
    info.birthDate = extractBirthDate(lines);
    info.samplingDate = extractSamplingDate(lines);
    info.fileDate = extractFileDate(lines);
    
    // Extraction médecin
    info.doctorName = extractDoctorName(lines);
    
    // Calcul de l'âge
    if (info.birthDate && info.samplingDate) {
        info.age = calculateAge(info.birthDate, info.samplingDate);
    }
    
    // Validation croisée
    info.confidence = validateDates(info.birthDate, info.samplingDate, info.fileDate);
    
    return info;
}

function extractPatientName(lines) {
    // Format standard : lignes 2-3
    if (lines.length >= 3) {
        const nom = lines[1]?.trim();
        const prenom = lines[2]?.trim();
        
        // Validation : pas de code médecin/labo
        if (nom && prenom && 
            !nom.match(/^[A-Z]{5,6}\s+/) && 
            !nom.match(/^\d+\s+/) &&
            nom.match(/^[A-Z\s-]+$/)) {
            return `${nom} ${prenom}`;
        }
    }
    
    // Format alternatif : recherche par pattern
    for (let i = 0; i < Math.min(10, lines.length - 1); i++) {
        const line = lines[i]?.trim();
        const nextLine = lines[i + 1]?.trim();
        
        if (line && nextLine && 
            line.match(/^[A-Z]+$/) && 
            nextLine.match(/^[A-Z-]+$/)) {
            return `${line} ${nextLine}`;
        }
    }
    
    return null;
}
            
            if (match) {
                const [, name, rawValue, unit, normes] = match;
                
                console.log('Match trouvé:', { name, rawValue, unit, normes });
                
                // Traiter les valeurs avec astérisques (anormales)
                let isHighlighted = false;
                let cleanValue = rawValue;
                
                if (rawValue.includes('*')) {
                    isHighlighted = true;
                    cleanValue = rawValue.replace(/\*/g, '');
                }
                
                // Normaliser la valeur (virgule vers point)
                const normalizedValue = normalizeNumericValue(cleanValue);
                const numericValue = parseFloat(normalizedValue);
                
                // Parser les normes (format: "min - max" ou "min-max")
                let min = null, max = null;
                if (normes) {
                    const normeMatch = normes.match(/([\d,\.]+)\s*-\s*([\d,\.]+)/);
                    if (normeMatch) {
                        min = parseFloat(normalizeNumericValue(normeMatch[1]));
                        max = parseFloat(normalizeNumericValue(normeMatch[2]));
                    }
                }
                
                // Déterminer si anormal
                let isAbnormal = isHighlighted;
                if (!isAbnormal && min !== null && max !== null && !isNaN(numericValue)) {
                    isAbnormal = numericValue < min || numericValue > max;
                }
                
                const result = {
                    name: name.trim() + ' :',
                    value1: isNaN(numericValue) ? cleanValue : numericValue,
                    unit1: unit,
                    min1: min,
                    max1: max,
                    isAbnormal: isAbnormal,
                    hasNorms: min !== null || max !== null,
                    hasMultipleUnits: false,
                    isHighlighted1: isHighlighted,
                    operator1: null,
                    comments: []
                };
                
                console.log('Résultat créé:', result);
                results.push(result);
            }
        }
    }
    
    console.log('Résultats texte lisible trouvés:', results.length);
    return results;
}

// Parser pour format HPRIM en texte libre (ancien - gardé en fallback)
function parseTextFormatHPRIM(content) {
    console.log('Parsing format texte libre (fallback)...');
    const lines = content.split('\n');
    const results = [];
    
    for (let i = 0; i < lines.length; i++) {
        const originalLine = lines[i];
        const line = originalLine.trim();
        
        // Chercher les lignes qui ressemblent à des résultats
        // Incluant celles qui commencent par des espaces (indentées)
        if ((originalLine.startsWith('          ') || originalLine.startsWith('        ')) && // Ligne indentée
            line.length > 10 && 
            !line.match(/^\d/) && // Ne commence pas par un chiffre
            !line.includes('Valeurs de référence') &&
            !line.includes('Technique') &&
            !line.includes('Les résultats') &&
            !line.includes('(ELISA') &&
            !line.includes('Selon les') &&
            line.includes('  ') && // Contient des espaces multiples (alignement)
            (line.includes('<') || line.includes('>') || line.match(/\d+[\.,]\d+/) || line.match(/\d+\s+\w+/))) {
            
            console.log('Ligne candidate trouvée:', line);
            
            // Essayer d'extraire le nom et la valeur
            const parts = line.split(/\s{2,}/); // Split sur 2+ espaces
            console.log('Parts:', parts);
            
            if (parts.length >= 2) {
                const name = parts[0].trim();
                let valueAndUnit = parts[1].trim();
                
                // Si il y a une 3ème partie, c'est probablement l'unité
                if (parts.length >= 3) {
                    const unit = parts[2].trim();
                    if (unit && unit.length < 10) { // Unité probable
                        valueAndUnit = valueAndUnit + ' ' + unit;
                    }
                }
                
                console.log('Name:', name, 'ValueAndUnit:', valueAndUnit);
                
                // Extraire valeur et unité
                const valueMatch = valueAndUnit.match(/^([<>]?\s*[\d\.,]+|négatif|positif|absent)/i);
                const unitMatch = valueAndUnit.match(/([a-zA-Z\/°%µ]+[\w\/]*)\s*$/);
                
                if (name.length > 2) {
                    // Ajouter " :" si pas déjà présent
                    const finalName = name.endsWith(':') ? name : name + ' :';
                    
                    const result = {
                        name: finalName,
                        value1: valueMatch ? valueMatch[0].trim() : valueAndUnit.split(' ')[0],
                        unit1: unitMatch ? unitMatch[1] : (valueAndUnit.split(' ').length > 1 ? valueAndUnit.split(' ').slice(-1)[0] : ''),
                        operator1: '',
                        min1: '',
                        max1: '',
                        isAbnormal: false,
                        hasNorms: false,
                        hasMultipleUnits: false,
                        isHighlighted1: valueAndUnit.includes('<') || valueAndUnit.includes('>'),
                        comments: []
                    };
                    
                    console.log('Résultat créé:', result);
                    results.push(result);
                }
            }
        }
    }
    
    console.log('Résultats texte libre trouvés:', results.length);
    return results;
}

// Fonctions helper pour le parsing
function parseRESLine(line) {
    // Parser une ligne RES| standard
    const parts = line.split('|');
    if (parts.length < 8) return null;
    
    const name = parts[1] ? parts[1].trim() : '';
    const code = parts[2] ? parts[2].trim() : '';
    const type = parts[3] ? parts[3].trim() : '';
    const valueStr = parts[4] ? parts[4].trim() : '';
    const unit = parts[5] ? parts[5].trim() : '';
    const normStr = parts[6] ? parts[6].trim() : '';
    let maxStr = parts[7] ? parts[7].trim() : '';
    
    if (!name || !valueStr || (type !== 'N' && type !== 'A')) return null;
    
    // Parser les normes au format "3,2-6,5" ou séparées
    let minStr = '';
    if (normStr && normStr.includes('-')) {
        const normParts = normStr.split('-');
        minStr = normParts[0].trim();
        if (normParts.length > 1 && !maxStr) {
            maxStr = normParts[1].trim();
        }
    } else {
        minStr = normStr;
    }
    
    const parsedValue = parseSpecialValue(valueStr);
    
    return {
        name: name.endsWith(':') ? name : name + ' :',
        code: code,
        value1: parsedValue.value,
        unit1: unit,
        min1: parseNorm(minStr),
        max1: parseNorm(maxStr),
        isHighlighted1: parsedValue.highlighted,
        operator1: parsedValue.operator,
        comments: []
    };
}

function processRawResults(rawResults) {
    // Convertir les résultats bruts en format final
    const groupedResults = [];
    
    for (const result of rawResults) {
        // Déterminer si anormal et s'il y a des normes
        let isAbnormal = result.isHighlighted1 || false;
        let hasNorms = (result.min1 !== null && result.min1 !== 0) || (result.max1 !== null && result.max1 !== 0 && result.max1 < 9999);
        
        if (hasNorms && !isAbnormal && result.value1 !== null) {
            if (result.min1 !== null && result.max1 !== null) {
                isAbnormal = result.value1 < result.min1 || result.value1 > result.max1;
            } else if (result.max1 !== null && result.max1 < 9999) {
                isAbnormal = result.value1 > result.max1;
            } else if (result.min1 !== null && result.min1 > 0) {
                isAbnormal = result.value1 < result.min1;
            }
        }
        
        groupedResults.push({
            name: result.name,
            isAbnormal: isAbnormal,
            hasNorms: hasNorms,
            hasMultipleUnits: false,
            value1: result.value1,
            unit1: result.unit1,
            min1: result.min1,
            max1: result.max1,
            value2: null,
            unit2: null,
            min2: null,
            max2: null,
            comments: result.comments || [],
            isHighlighted1: result.isHighlighted1,
            isHighlighted2: false,
            operator1: result.operator1,
            operator2: null
        });
    }
    
    return groupedResults;
}

// Fonctions utilitaires pour parser les valeurs spéciales (améliorée)
function parseSpecialValue(valueStr) {
    if (!valueStr || valueStr === '') {
        return { value: null, highlighted: false, operator: null };
    }
    
    let cleanValue = valueStr.trim();
    let highlighted = false;
    let operator = null;
    
    // Gérer les astérisques (valeurs anormales mises en évidence)
    if (cleanValue.includes('*')) {
        highlighted = true;
        cleanValue = cleanValue.replace(/\*/g, '');
    }
    
    // Gérer les opérateurs de comparaison
    if (cleanValue.startsWith('<')) {
        operator = '<';
        cleanValue = cleanValue.substring(1);
    } else if (cleanValue.startsWith('>')) {
        operator = '>';
        cleanValue = cleanValue.substring(1);
    }
    
    // Normaliser les décimales (virgule vers point)
    cleanValue = normalizeNumericValue(cleanValue);
    
    // Convertir en nombre
    const numericValue = parseFloat(cleanValue);
    
    return {
        value: isNaN(numericValue) ? cleanValue : numericValue,
        highlighted: highlighted,
        operator: operator
    };
}

function parseNorm(normStr) {
    if (!normStr || normStr === '') return null;
    const cleaned = normStr.replace(',', '.');
    const parsed = parseFloat(cleaned);
    return isNaN(parsed) ? null : parsed;
}

function formatValue(value, operator, highlighted) {
    if (value === null) return '';
    
    let formatted = (operator || '') + value;
    
    if (highlighted) {
        formatted = `<strong style="color: #ff5722;">${formatted}</strong>`;
    }
    
    return formatted;
}

function formatNorms(min, max, result) {
    // Normes spéciales pour le DFG
    if (result && result.name && result.name.toLowerCase().includes('dfg')) {
        return '(> 60)';
    }
    if (result && result.code && result.code.includes('1.6')) {
        return '(> 60)';
    }
    
    if (min !== null && max !== null) {
        return `(${min} - ${max})`;
    } else if (max !== null) {
        return `(< ${max})`;
    } else if (min !== null) {
        return `(> ${min})`;
    }
    return '';
}

// Fonctions d'extraction des informations patient
function extractPatientInfo(content) {
    const lines = content.split('\n');
    const info = {};
    
    // Extraction du nom patient (lignes 2-3)
    info.patientName = extractPatientName(lines);
    
    // Extraction des dates
    info.birthDate = extractBirthDate(lines);
    info.samplingDate = extractSamplingDate(lines);
    info.fileDate = extractFileDate(lines);
    
    // Extraction médecin
    info.doctorName = extractDoctorName(lines);
    
    // Calcul de l'âge
    if (info.birthDate && info.samplingDate) {
        info.age = calculateAge(info.birthDate, info.samplingDate);
    }
    
    // Validation croisée
    info.confidence = validateDates(info.birthDate, info.samplingDate, info.fileDate);
    
    return info;
}

function extractPatientName(lines) {
    // Format standard : lignes 2-3
    if (lines.length >= 3) {
        const nom = lines[1]?.trim();
        const prenom = lines[2]?.trim();
        
        // Validation : pas de code médecin/labo
        if (nom && prenom && 
            !nom.match(/^[A-Z]{5,6}\s+/) && 
            !nom.match(/^\d+\s+/) &&
            nom.match(/^[A-Z\s-]+$/)) {
            return `${nom} ${prenom}`;
        }
    }
    
    // Format alternatif : recherche par pattern
    for (let i = 0; i < Math.min(10, lines.length - 1); i++) {
        const line = lines[i]?.trim();
        const nextLine = lines[i + 1]?.trim();
        
        if (line && nextLine && 
            line.match(/^[A-Z]+$/) && 
            nextLine.match(/^[A-Z-]+$/)) {
            return `${line} ${nextLine}`;
        }
    }
    
    return null;
}

function extractBirthDate(lines) {
    // Priorité 1 : Ligne 7 (format standard)
    if (lines.length >= 7) {
        const dateCandidate = lines[6]?.trim();
        if (dateCandidate && dateCandidate.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
            const birthYear = parseInt(dateCandidate.split('/')[2]);
            // Validation : année de naissance réaliste (1920-2024)
            if (birthYear >= 1920 && birthYear <= 2024) {
                return parseDate(dateCandidate);
            }
        }
    }
    
    // Priorité 2 : Recherche "Date de Naissance" dans section HTML
    for (let i = 15; i < Math.min(25, lines.length); i++) {
        const line = lines[i] || '';
        if (line.includes('Date de Naissance')) {
            const match = line.match(/(\d{2}-\d{2}-\d{4})/);
            if (match) {
                return parseDate(match[1].replace(/-/g, '/'));
            }
        }
    }
    
    return null;
}

function extractSamplingDate(lines) {
    // Priorité 1 : Ligne 10 (format standard)
    if (lines.length >= 10) {
        const dateCandidate = lines[9]?.trim();
        if (dateCandidate && dateCandidate.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
            return parseDate(dateCandidate);
        }
    }
    
    // Priorité 2 : Recherche "Date demande" dans section HTML
    for (let i = 13; i < Math.min(25, lines.length); i++) {
        const line = lines[i] || '';
        if (line.includes('Date demande')) {
            const match = line.match(/(\d{2}-\d{2}-\d{4})/);
            if (match) {
                return parseDate(match[1].replace(/-/g, '/'));
            }
        }
    }
    
    // Priorité 3 : Date après numéro de dossier
    for (let i = 0; i < Math.min(15, lines.length - 1); i++) {
        const line = lines[i]?.trim();
        if (line && line.match(/^[AB]\d{9}/)) {
            const nextLine = lines[i + 1]?.trim();
            if (nextLine && nextLine.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
                return parseDate(nextLine);
            }
        }
    }
    
    return null;
}

function extractFileDate(lines) {
    // Priorité 1 : "Validation le" (date de finalisation du dossier)
    for (let i = 20; i < Math.min(30, lines.length); i++) {
        const line = lines[i] || '';
        if (line.includes('Validation le')) {
            const match = line.match(/(\d{2}-\d{2}-\d{4})/);
            if (match) {
                return parseDate(match[1].replace(/-/g, '/'));
            }
        }
    }
    
    // Par défaut, utiliser la date de prélèvement
    return extractSamplingDate(lines);
}

function extractDoctorName(lines) {
    // Priorité 1 : Section HTML "Médecin :"
    for (let i = 13; i < Math.min(20, lines.length); i++) {
        const line = lines[i] || '';
        if (line.includes('M&eacute;decin :') || line.includes('Médecin :')) {
            // Nettoyer les balises HTML
            const cleanLine = line.replace(/<[^>]+>/g, '').replace(/&eacute;/g, 'é');
            const match = cleanLine.match(/M[éê]decin\s*:\s*([A-Z\s-]+)/);
            if (match) {
                return match[1].trim();
            }
        }
    }
    
    // Priorité 2 : Ligne 12 (code + nom)
    if (lines.length >= 12) {
        const line12 = lines[11]?.trim();
        if (line12) {
            // Pattern : CODE      nom.prenom
            const match = line12.match(/^[A-Z]{5,6}\s+([a-z\.-]+)/);
            if (match) {
                const nameParts = match[1].replace(/\./g, ' ').split(/\s+/);
                return nameParts.map(part => part.charAt(0).toUpperCase() + part.slice(1)).join(' ');
            }
        }
    }
    
    return null;
}

function parseDate(dateStr) {
    if (!dateStr) return null;
    const parts = dateStr.split('/');
    if (parts.length === 3) {
        return new Date(parseInt(parts[2]), parseInt(parts[1]) - 1, parseInt(parts[0]));
    }
    return null;
}

function calculateAge(birthDate, referenceDate) {
    if (!birthDate || !referenceDate) return null;
    const diffTime = referenceDate - birthDate;
    const diffYears = diffTime / (1000 * 60 * 60 * 24 * 365.25);
    return Math.floor(diffYears);
}

function validateDates(birthDate, samplingDate, fileDate) {
    let confidence = 1.0;
    
    if (birthDate && samplingDate) {
        const age = calculateAge(birthDate, samplingDate);
        if (age < 0 || age > 120) {
            confidence *= 0.3; // Très faible confiance si âge irréaliste
        }
    }
    
    if (samplingDate && fileDate) {
        if (fileDate < samplingDate) {
            confidence *= 0.5; // Confiance réduite si date de dossier antérieure
        }
    }
    
    return confidence;
}

function generatePatientHeader(patientInfo) {
    let headerHtml = `<div style="background: #e3f2fd; padding: 15px; margin: 15px 0; border-radius: 8px; border-left: 4px solid #1976d2;">`;
    
    // Première ligne : Nom + âge + date de naissance
    let firstLine = '';
    if (patientInfo.patientName) {
        firstLine += `<strong style="color: #1976d2; font-size: 1.1rem;">${patientInfo.patientName}</strong>`;
    }
    
    if (patientInfo.age !== null && patientInfo.age !== undefined) {
        if (firstLine) firstLine += '   ';
        firstLine += `<strong style="font-size: 1.1rem;">${patientInfo.age} ans</strong>`;
    }
    
    if (patientInfo.birthDate) {
        const birthDateStr = formatDate(patientInfo.birthDate);
        if (firstLine) firstLine += '   ';
        firstLine += `<span style="font-size: 1.1rem;">Né(e) le ${birthDateStr}</span>`;
    }
    
    if (firstLine) {
        headerHtml += `<div style="margin-bottom: 8px;">${firstLine}</div>`;
    }
    
    // Deuxième ligne : Prélèvement + médecin
    let secondLine = '';
    if (patientInfo.samplingDate) {
        const dateStr = formatDate(patientInfo.samplingDate);
        secondLine += `Prélèvement : ${dateStr}`;
    }
    
    if (patientInfo.doctorName) {
        if (secondLine) secondLine += ' • ';
        secondLine += `Dr ${patientInfo.doctorName}`;
    }
    
    if (secondLine) {
        headerHtml += `<div style="color: #666; font-size: 0.9rem;">${secondLine}</div>`;
    }
    
    if (patientInfo.confidence < 0.8) {
        headerHtml += `<div style="color: #ff9800; font-size: 0.8rem; margin-top: 5px;">⚠️ Informations extraites avec confiance réduite</div>`;
    }
    
    headerHtml += `</div>`;
    return headerHtml;
}

function formatDate(date) {
    if (!date) return '';
    const day = date.getDate().toString().padStart(2, '0');
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const year = date.getFullYear();
    return `${day}/${month}/${year}`;
}